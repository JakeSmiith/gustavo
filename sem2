# Q1) Loading Packages and Setup
# a) Set the working library paths so both a user-specific and a system-wide path are recognised.
.libPaths(c(.libPaths(), "C:/Users/tpd19wzu/Documents/R/MyLibrary"))
.libPaths(c(.libPaths(), "C:/Program Files/R/R-4.1.3/library"))


# b)Create a single command that installs all required packages only if not already installed.
packages <- c("quantmod", "tidyverse", "PerformanceAnalytics", "timeSeries", "tseries",
              "roll", "car", "MASS", "extraDistr", "rugarch", "QRM", "dplyr",
              "reshape2", "lubridate")

install_if_missing <- function(pkg) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    install.packages(pkg, dependencies = TRUE)
  }
}
invisible(lapply(packages, install_if_missing))

# c) Use a loop to load all libraries from a character vector.
lapply(packages, library, character.only = TRUE)

# Q2) Data Import and Initial Exploration
# a) Import the 'crsp_seminar1.csv' file and inspect the first few and last few rows.
data <- read.csv('crsp_seminar1.csv') 
view(data)            
head(data)
tail(data)

# b) What type of object is returned by read.csv()? Confirm using a function
class(data) # returns 'data.frame'

# c)  Create new columns for 'Adjusted_Prices' and 'Unadjusted_Prices' using the CFACPR scaling factor.
data$Unadjusted_Prices <- data$PRC
data$Adjusted_Prices <- data$PRC / data$CFACPR

# 3) Firm-Specific Data Frames and Merging
# a) Subset the 'Adjusted_Prices' column for specific PERMNO codes and rename each column appropriately.
MSFT <- data[data$PERMNO == 10107, c("date", "Adjusted_Prices")]
names(MSFT)[2] <- "MSFT"

XOM <- data[data$PERMNO==11850, c("date", "Adjusted_Prices")]
names(XOM)[2] <- "XOM"

GE <- data[data$PERMNO==12060, c("date", "Adjusted_Prices")]
names(GE)[2] <- "GE"

JPM <- data[data$PERMNO==47896, c("date", "Adjusted_Prices")]
names(JPM)[2] <- "JPM"

MCD <- data[data$PERMNO==43449, c("date", "Adjusted_Prices")]
names(MCD)[2] <- "MCD"

C <- data[data$PERMNO==70519, c("date", "Adjusted_Prices")]
names(C)[2] <- "C"

# b) Merge the individual stock data frames into a single wide-format data frame.
PRC <- merge(MSFT, XOM)
PRC <- merge(PRC, GE)
PRC <- merge(PRC, JPM)
PRC <- merge(PRC, MCD)
PRC <- merge(PRC, C)

# c) Rewrite this using a loop that dynamically builds the combined price frame.
stocks <- list(
  MSFT = 10107,
  XOM = 11850,
  GE = 12060,
  JPM = 47896,
  MCD = 43449,
  C = 70519
)

for (s in 1:length(stocks)) {
  stock_data <- data[data$PERMNO == stocks[s], c("date", "Adjusted_Prices")]
  names(stock_data)[2] <- names(stocks[s]) 
  if (s==1) {
    PRC_loop <-stock_data
  } else {
    PRC_loop<-merge(PRC_loop, stock_data)
  }
}

# Q4) Alternative Reshaping with reshape2::dcast
# a) Use `dcast()` to reshape the TICKER variable to wide format using PERMNOs.
Tickers = dcast(data, date ~ PERMNO, value.var = "TICKER")
Tickers = tail(Tickers, 1)
Tickers

# b) Use `dcast()` to reshape the Adjusted Prices and assign appropriate column names.
Prices = dcast(data, date ~ PERMNO, value.var = "Adjusted_Prices")
names(Prices) <- Tickers
names(Prices)[1] = "date"
head(Prices)

#c) Repeat for unadjusted prices and simple returns. Check dimensions of resulting data frames.
UnAdjustedPrices = dcast(data, date ~ PERMNO, value.var = "PRC")
names(UnAdjustedPrices) <- Tickers
names(UnAdjustedPrices)[1] = "date"
head(UnAdjustedPrices)
dim(UnAdjustedPrices)

# Q5) Creating and transforming returns
# a) Convert simple returns to log returns using the log(1 + R_t) formula.
simpleReturns = dcast(data, date ~ PERMNO, value.var = "RET")
names(simpleReturns) <- Tickers
names(simpleReturns)[1] = "date"
Returns = log(1 + simpleReturns[,2:dim(simpleReturns)[2]])
Returns$date = simpleReturns$date
head(Returns)

# b) Bring the 'date' column to the first position using column reordering.
Returns = Returns[,c(dim(Returns)[2],1:(dim(Returns)[2]-1))]
head(Returns)

# c) Convert integer-formatted dates to proper date format using `ymd()`.
ReturnsDate <- Returns
ReturnsDate$date <- ymd(ReturnsDate$date)
head(ReturnsDate)
class(ReturnsDate$date)

# Q6) Saving and Exporting Data
# a) Save all key data frames as `.RData` files using `save()`.
save(simpleReturns, file = "simpleReturns.RData")
save(Returns, file = "Returns.RData")
save(Prices, file = "Prices.RData")
save(UnAdjustedPrices, file = "UnAdjustedPrices.RData")
save(ReturnsDate, file = "ReturnsDate.RData")

# b) Export the Prices data frame as a .csv file using write.csv()
write.csv(Prices, file = "Prices.csv")

# Q7) Plotting Prices and Returns
# a) Create base plots of JPM returns using both raw and line-type options

plot(Returns$JPM)             
plot(Returns$JPM, type = "l") 

# b) Explain why plotting with raw integer date does not work well for time series
dev.new()
plot(Returns$date, Returns$JPM,
     type = "l",
     main = "Compound returns for JP Morgan",
     ylab = "Returns",
     xlab = "Date",
     col = "red",
     las = 1
)

# c)  Recreate the plot using the corrected date.ts format
date.ts <- ymd(Returns$date)

dev.new() # new figure
plot(date.ts, Returns$JPM,
     type = "l",
     main = "Compound returns for JP Morgan",
     ylab = "Returns",
     xlab = "Date",
     col = "red",
     las = 1
)

# d) Plot prices for multiple firms using lines() and legend()
dev.new()
plot(date.ts, Prices$JPM, type = "l", main = "Prices for JP Morgan and Citi",
     ylab = "Price", xlab = "Date", col = "red")
lines(date.ts, Prices$C, col = "blue")
lines(date.ts, Prices$MSFT, col = "green")
legend("bottomright", legend = c("JPM", "C", "MSFT"), col = c("red", "blue", "green"), lty = 1, bty = 'n')

#e) Control the y-axis using ylim()
dev.new() 
plot(date.ts, Prices$JPM, type = "l", main = "Prices for JP Morgan and Citi",
     ylab = "Price", xlab = "Date", col = "red", ylim = c(0, 600))
lines(date.ts, Prices$C, col = "blue")
lines(date.ts, Prices$MSFT, col = "green")
legend("bottomright", legend = c("JPM", "C", "MSFT"), col = c("red", "blue", "green"), lty = 1, bty = 'n')

#Q8) Advanced visualisation techniques
#a) Export a multi-line plot as a PDF using pdf() and dev.off()
# Save plot of all adjusted prices to PDF
pdf(file = "Seminar2_plot.pdf", width = 8, height = 6, paper = "a4", bg = "white", pointsize = 12)

matplot(date.ts, Prices[,2:dim(Prices)[2]],
        type = "l",
        lty = 1,                         # Solid lines
        main = "Prices",
        ylab = "Price",
        xlab = "Date",
        col = 1:6,                       # Each line a different colour
        las = 1                          # Horizontal axis labels
)

dev.off()  # Close PDF device

# b) Compare adjusted vs. unadjusted prices for MSFT using matplot()
dev.new()
matplot(date.ts,
        cbind(Prices$MSFT, UnAdjustedPrices$MSFT),
        type = "l",
        lty = 1,
        col = c("blue", "red"),
        main = "Adjusted and Unadjusted Prices for MSFT",
        ylab = "USD"
)
legend("topleft", legend = c("Adjusted", "Unadjusted"), col = c("blue", "red"), lty = 1, bty = "n")

# c) Use par(mfrow = ...) and loop for subplots of all returns
dev.new()
par(mfrow = c(3,2))  # 3 rows, 2 columns layout

for (i in 2:dim(Returns)[2]) {
  plot(date.ts, Returns[, i],
       type = "l",
       ylab = "Returns",
       xlab = "Date",
       main = paste("Returns for", names(Prices)[i])
  )
}

# Q9) Normalising Price Levels
# a) Create new data frame where each price series is normalised to start at 1
normalizedPrices <- Prices
normalizedPrices$MSFT <- normalizedPrices$MSFT / normalizedPrices[1, "MSFT"]
normalizedPrices$XOM  <- normalizedPrices$XOM  / normalizedPrices[1, "XOM"]
normalizedPrices$GE   <- normalizedPrices$GE   / normalizedPrices[1, "GE"]
normalizedPrices$MCD  <- normalizedPrices$MCD  / normalizedPrices[1, "MCD"]
normalizedPrices$JPM  <- normalizedPrices$JPM  / normalizedPrices[1, "JPM"]
normalizedPrices$C    <- normalizedPrices$C    / normalizedPrices[1, "C"]
head(normalizedPrices)

# b) Plot normalised prices for comparison using matplot()
dev.new()
matplot(date.ts,
        cbind(normalizedPrices$MSFT,
              normalizedPrices$XOM,
              normalizedPrices$GE,
              normalizedPrices$MCD,
              normalizedPrices$JPM,
              normalizedPrices$C),
        type = "l",
        lty = 1,
        col = 1:6,
        main = "Normalised Prices",
        ylab = "Normalised Price",
        xlab = "Date"
)
legend("topleft", legend = colnames(normalizedPrices)[-1], col = 1:6, lty = 1, bty = "n")

# c) Generate a log-scaled plot for MSFT using the log = "y" option in plot()
dev.new()
plot(date.ts, Prices$MSFT,
     type = "l",
     log = "y",
     main = "Log-Scaled Price for MSFT",
     ylab = "Log(Price)",
     xlab = "Date",
     col = "purple"
)





